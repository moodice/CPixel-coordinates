/******************************/
/*        立体匹配和测距        */
/******************************/

#include <opencv2/opencv.hpp>  
#include <iostream>  
#include "opencv2/imgcodecs/legacy/constants_c.h"
#include <opencv2\imgproc\types_c.h>
#include <opencv2/highgui/highgui_c.h>

using namespace std;
using namespace cv;

const int imageWidth = 1024;                             //摄像头的分辨率  
const int imageHeight = 768;
Size imageSize = Size(imageWidth, imageHeight);

Mat rgbImageL, grayImageL;
Mat rgbImageR, grayImageR;
Mat rectifyImageL, rectifyImageR;

Rect validROIL;//图像校正之后，会对图像进行裁剪，这里的validROI就是指裁剪之后的区域  
Rect validROIR;

Mat mapLx, mapLy, mapRx, mapRy;     //映射表  
Mat Rl, Rr, Pl, Pr, Q;              //校正旋转矩阵R，投影矩阵P 重投影矩阵Q
Mat xyz;              //三维坐标

Point origin;         //鼠标按下的起始点
Rect selection;      //定义矩形选框
bool selectObject = false;    //是否选择对象

int blockSize = 0, uniquenessRatio = 0, numDisparities = 0;
Ptr<StereoBM> bm = StereoBM::create(16, 9);

/*
事先标定好的相机的参数
fx 0 cx
0 fy cy
0 0  1
*/
Mat cameraMatrixL = (Mat_<double>(3, 3) << 
    3043.965495, 1.816886326, 646.6591164,
    0, 3062.429893, 318.6606484,
    0, 0, 1
    );
/*3043.965495,0,0,
1.816886326,3062.429893,0,
646.6591164,318.6606484,1
3043.965495, 1.816886326,646.6591164,
    0,3062.429893,318.6606484,
    0,0,1*/


//畸变(k1,k2,p1,p2,k3)
Mat distCoeffL = (Mat_<double>(5, 1) << 1, 0, 0, 0, 0
    );
//0.611568177,-119.2323681,6980.461906,-0.009666281,0.009310385
//0.611568177,-119.2323681, -0.009666281,0.009310385,6980.461906
//-0.009666281,0.009310385,0.611568177,-119.2323681,6980.461906



Mat cameraMatrixR = (Mat_<double>(3, 3) << 
    3048.550122, -9.738518169, 544.1579293,
    0, 3068.422702, 230.6478814,
    0, 0, 1
    );
/*3048.550122,0,0,
-9.738518169,3068.422702,0,
544.1579293,230.6478814,1
3048.550122, -9.738518169,544.1579293,
    0,3068.422702,230.6478814,
    0,0,1
*/
Mat distCoeffR = (Mat_<double>(5, 1) << 0.3285412648190094, -13.96276464161761, -0.03000457328682077, -0.02636697924848531, 130.1467536974576
    );
//0.096951793,-1.340593865,-32.78274225,-0.01879748,0.006495002 
//0.096951793,-1.340593865, -0.01879748,0.006495002,-32.78274225
//-0.01879748,0.006495002,0.096951793,-1.340593865,-32.78274225


Mat T = (Mat_<double>(3, 1) << -914.5883933, -60.02969331, 14.41187854);//T平移向量 -914.5883933 ,-60.02969331,14.41187854
//Mat rec = (Mat_<double>(3, 1) << -0.00306, -0.03207, 0.00206);//rec旋转向量
Mat R=(Mat_<double>(3,3)<< 
    0.997221835, -0.065171435, 0.036073491,
    0.066350242, 0.997266768, 0.032505968,
    -0.033856433, -0.034809146, 0.998820337
    );//R 旋转矩阵
/*0.997221835,0.065171435,-0.036073491,
    -0.066350242,0.997266768,-0.032505968,
    0.033856433,0.034809146,0.998820337
    1,0,0,
    0,1,0,
    0,0,1*/

/*****立体匹配*****/
//void stereo_match(int, void*)
//{
//    bm->setBlockSize(2 * blockSize + 5);     //SAD窗口大小，5~21之间为宜
//    bm->setROI1(validROIL);
//    bm->setROI2(validROIR);
//    bm->setPreFilterCap(31);
//    bm->setMinDisparity(0);  //最小视差，默认值为0, 可以是负值，int型
//    bm->setNumDisparities(numDisparities * 16 + 16);//视差窗口，即最大视差值与最小视差值之差,窗口大小必须是16的整数倍，int型
//    bm->setTextureThreshold(10);
//    bm->setUniquenessRatio(uniquenessRatio);//uniquenessRatio主要可以防止误匹配
//    bm->setSpeckleWindowSize(100);
//    bm->setSpeckleRange(32);
//    bm->setDisp12MaxDiff(-1);
//    Mat disp, disp8;
//    bm->compute(rectifyImageL, rectifyImageR, disp);//输入图像必须为灰度图
//    disp.convertTo(disp8, CV_8U, 255 / ((numDisparities * 16 + 16) * 16.0));//计算出的视差是CV_16S格式
//    reprojectImageTo3D(disp, xyz, Q, true); //在实际求距离时，ReprojectTo3D出来的X / W, Y / W, Z / W都要乘以16(也就是W除以16)，才能得到正确的三维坐标信息。
//    xyz = xyz * 16;
//    imshow("disparity", disp8);
//}

/*****描述：鼠标操作回调*****/
//static void onMouse(int event, int x, int y, int, void*)
//{
//    if (selectObject)
//    {
//        selection.x = MIN(x, origin.x);
//        selection.y = MIN(y, origin.y);
//        selection.width = std::abs(x - origin.x);
//        selection.height = std::abs(y - origin.y);
//    }
//
//    switch (event)
//    {
//    case EVENT_LBUTTONDOWN:   //鼠标左按钮按下的事件
//        origin = Point(x, y);
//        selection = Rect(x, y, 0, 0);
//        selectObject = true;
//        cout << origin << "in world coordinate is: " << xyz.at<Vec3f>(origin) << endl;
//        break;
//    case EVENT_LBUTTONUP:    //鼠标左按钮释放的事件
//        selectObject = false;
//        if (selection.width > 0 && selection.height > 0)
//            break;
//    }
//}


/*****主函数*****/
int main()
{
    /*
    立体校正
    */
    //Rodrigues(rec, R); //Rodrigues变换
    stereoRectify(cameraMatrixL, distCoeffL, cameraMatrixR, distCoeffR, imageSize, R, T, Rl, Rr, Pl, Pr, Q, CALIB_ZERO_DISPARITY,
        0, imageSize, &validROIL, &validROIR);
    initUndistortRectifyMap(cameraMatrixL, distCoeffL, Rl, Pr, imageSize, CV_32FC1, mapLx, mapLy);
    initUndistortRectifyMap(cameraMatrixR, distCoeffR, Rr, Pr, imageSize, CV_32FC1, mapRx, mapRy);

    /*
    读取图片
    */
    rgbImageL = imread("D:\\编程\\CPixel coordinates\\Right\\4880.png", CV_LOAD_IMAGE_COLOR);//Right
    cvtColor(rgbImageL, grayImageL, CV_BGR2GRAY);
    rgbImageR = imread("D:\\编程\\CPixel coordinates\\Left\\4880.png", CV_LOAD_IMAGE_COLOR);//Left
    cvtColor(rgbImageR, grayImageR, CV_BGR2GRAY);

    imshow("ImageL Before Rectify", grayImageL);
    imshow("ImageR Before Rectify", grayImageR);

    /*
    经过remap之后，左右相机的图像已经共面并且行对准了
    */
    remap(grayImageL, rectifyImageL, mapLx, mapLy, INTER_LINEAR);
    remap(grayImageR, rectifyImageR, mapRx, mapRy, INTER_LINEAR);

    /*
    把校正结果显示出来
    */
    Mat rgbRectifyImageL, rgbRectifyImageR;
    cvtColor(rectifyImageL, rgbRectifyImageL, CV_GRAY2BGR);  //伪彩色图 CV_GRAY2BGR
    cvtColor(rectifyImageR, rgbRectifyImageR, CV_GRAY2BGR);//CV_GRAY2BGR
    
    //单独显示
   /* rectangle(rgbRectifyImageL, validROIL, Scalar(0, 0, 255), 3, 8);
    rectangle(rgbRectifyImageR, validROIR, Scalar(0, 0, 255), 3, 8);*/
    imshow("ImageL After Rectify", rgbRectifyImageL);
    imshow("ImageR After Rectify", rgbRectifyImageR);

    //显示在同一张图上
    Mat canvas;
    double sf;
    int w, h;
    sf =  600.0 / MAX(imageSize.width, imageSize.height);
    w = cvRound(imageSize.width * sf);
    h = cvRound(imageSize.height * sf);
    canvas.create(h, w * 2, CV_8UC3);   //注意通道

    //左图像画到画布上
    Mat canvasPart = canvas(Rect(w * 0, 0, w, h));                                //得到画布的一部分  
    resize(rgbRectifyImageL, canvasPart, canvasPart.size(), 0, 0, INTER_AREA);     //把图像缩放到跟canvasPart一样大小  
    Rect vroiL(cvRound(validROIL.x * sf), cvRound(validROIL.y * sf),                //获得被截取的区域    
        cvRound(validROIL.width * sf), cvRound(validROIL.height * sf));
    //rectangle(canvasPart, vroiL, Scalar(0, 0, 255), 3, 8);                      //画上一个矩形  
    cout << "Painted ImageL" << endl;

    //右图像画到画布上
    canvasPart = canvas(Rect(w, 0, w, h));                                      //获得画布的另一部分  
    resize(rgbRectifyImageR, canvasPart, canvasPart.size(), 0, 0, INTER_LINEAR);
    Rect vroiR(cvRound(validROIR.x * sf), cvRound(validROIR.y * sf),
        cvRound(validROIR.width * sf), cvRound(validROIR.height * sf));
    //rectangle(canvasPart, vroiR, Scalar(0, 0, 255), 3, 8);
    cout << "Painted ImageR" << endl;

    //画上对应的线条
    for (int i = 0; i < canvas.rows; i += 16)
        line(canvas, Point(0, i), Point(canvas.cols, i), Scalar(0, 255, 0), 1, 8);
    imshow("rectified", canvas);

    /*
    立体匹配
    */
   /* namedWindow("disparity", CV_WINDOW_AUTOSIZE);
     //创建SAD窗口 Trackbar
    createTrackbar("BlockSize:\n", "disparity", &blockSize, 8, stereo_match);
     //创建视差唯一性百分比窗口 Trackbar
    createTrackbar("UniquenessRatio:\n", "disparity", &uniquenessRatio, 50, stereo_match);
     //创建视差窗口 Trackbar
    createTrackbar("NumDisparities:\n", "disparity", &numDisparities, 16, stereo_match);
    //鼠标响应函数setMouseCallback(窗口名称, 鼠标回调函数, 传给回调函数的参数，一般取0)
    setMouseCallback("disparity", onMouse, 0);
    stereo_match(0, 0);*/

    waitKey(0);
    return 0;
}
//#include "pch.h"
//#include <iostream>
//#include <math.h>
//#include <opencv2/opencv.hpp>
//
//using namespace std;
//using namespace cv;
//
//int main()
//{
//    Mat img1 = imread("D:\\编程\\CPixel coordinates\\Left\\4890.png");
//    Mat img2 = imread("D:\\编程\\CPixel coordinates\\Right\\4890.png");
//    if (img1.empty() || img2.empty())
//    {
//        cout << "加载图片失败，请检查对应路径图片是否存在！" << endl;
//        return 1;
//    }
//    imshow("src1", img1);
//    imshow("src2", img2);
//    int w1 = img1.cols; int h1 = img1.rows;
//    int w2 = img2.cols; int h2 = img2.rows;
//    int width = w1 + w2; int height = max(h1, h2);
//    Mat  resultImg = Mat(height, width, CV_8UC3, Scalar::all(0));
//    Mat ROI_1 = resultImg(Rect(0, 0, w1, h1));
//    Mat ROI_2 = resultImg(Rect(w1, 0, w2, h2));
//    img1.copyTo(ROI_1);
//    img2.copyTo(ROI_2);
//    imshow("result", resultImg);
//    imwrite("result.jpg", resultImg);
//    waitKey(0);
//    return 0;
//}